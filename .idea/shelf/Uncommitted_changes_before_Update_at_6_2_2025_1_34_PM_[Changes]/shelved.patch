Index: Scripts/Gui_tkinter/widgets/PlottingWindow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nJunk for integrating plotting visuals into the GUI window\r\n\"\"\"\r\nimport pickle\r\nimport io\r\nimport magpylib as mp\r\nfrom magpylib.current import Circle\r\nfrom pathlib import Path\r\nimport os\r\nimport tkinter as tk\r\nfrom tkinter import messagebox\r\nfrom tkinter import ttk\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib as mpl\r\nfrom matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,\r\n                                               NavigationToolbar2Tk)\r\nfrom Gui_tkinter.funcs.GuiEntryHelpers import (JSON_to_Df, tryEval, CSV_to_Df)\r\nimport pandas as pd\r\nfrom calcs.BorisAnalysis import *\r\nfrom settings.notifs import Popup_Notifs, Title_Notif\r\nfrom system.temp_manager import TEMPMANAGER_MANAGER\r\nimport system.temp_file_names as names\r\nimport h5py\r\n\r\n\"\"\"\r\nthe following r settings and callables that the classes will implement.\r\n\"\"\"\r\ndpi = 100 # dpi of the graphs\r\ndropdown_font_textsize_proportion = 3\r\ntrajectory_font_textsize_proportion = 4\r\n\r\n# SETTINGS FOR NEW TOPLEVEL WINDOW GRAPH\r\n# these are in inches.\r\ntoplevel_width = 8\r\ntoplevel_height = 4\r\n\r\n# DEFAULT GRAPH SETTINGS:\r\ngraph_default = {\r\n            \"projection\" : 'rectilinear',\r\n            \"title\" : \"New Graph\",\r\n            \"xlab\" : 'X (m)',\r\n            \"ylab\" : \"Y (m)\",\r\n            'zlab' : 'Z (m)'\r\n}\r\n\r\n# GRAPH STYLES: HOW TO SET UP EACH TYPE OF GRAPH (labels and stuff)\r\n# defined only where they stray from the default settings.\r\n\"\"\"\r\nReminder: the actual, complete style dict is stored as the graph_settings property in a CanvasFigure object.\r\nIt's done like this so I don't have to type literally everything.\r\n\"\"\"\r\ntrajectory_style = {\r\n    \"projection\" : '3d',\r\n    'title' : 'Trajectory',\r\n    'zlab' : 'Z (m)',\r\n    'ylab' : 'Y (m)',\r\n    'xlab' : 'X (m)'\r\n}\r\n\r\nvel_step_style = {\r\n    'title' : 'Vel vs. Step',\r\n    'ylab' : 'm/s',\r\n    'xlab' : 'step'\r\n}\r\n\r\nb_step_style = {\r\n    'title' : 'B-mag vs. Step',\r\n    'ylab' : 'T',\r\n    'xlab' : 'step'\r\n}\r\n\r\ne_step_style = {\r\n    'title' : 'E-mag vs. Step',\r\n    'ylab' : 'V per m',\r\n    'xlab' : 'step'\r\n}\r\n\r\n# available graphing options. Stored in a ttk.combobx.\r\ngraph_options = ('Vel vs. Step',\r\n                 'B-mag vs. Step',\r\n                 'E-mag vs. Step')\r\n\r\n# GRAPHING FUNCTIONS - each option should be accompanied by a function.\r\n\"\"\"\r\nThese functions expect a pre-labelled, empty subplot to draw on.\r\nAlso, they do not call the draw function. That should be done externally.\r\n\r\nPls note that right now, they will only graph the data of particle 0.\r\n\"\"\"\r\ndef Param_v_Step_callable(fig, plot, path, id, **kwargs):\r\n    \"\"\"\r\n    for tracking a single parameter involved in the simulation as a linegraph respective to the step count.\r\n    used for the vel, b-mag, e-mag v, step graphs.\r\n    \"\"\"\r\n    h5_dct = {\"v\" : {'xn' : 'vx',\r\n                     'yn' : 'vy',\r\n                     'zn' : 'vz',\r\n                     'mag_key' : 'vmag',\r\n                     'perp_key' : 'vperp',\r\n                     'par_key' : 'vpar',\r\n                     'src' : '/src/velocity'},\r\n\r\n              \"b\" : {'xn' : 'bx',\r\n                     'yn' : 'by',\r\n                     'zn' : 'bz',\r\n                     'mag_key' : 'bmag',\r\n                     'perp_key' : 'bperp',\r\n                     'par_key' : 'bpar',\r\n                     'src' : 'src/fields/b'},\r\n\r\n              'e' : {'xn' : 'ex',\r\n                     'yn' : 'ey',\r\n                     'zn' : 'ez',\r\n                     'mag_key' : 'emag',\r\n                     'perp_key' : 'eperp',\r\n                     'par_key' : 'epar',\r\n                     'src' : 'src/fields/e'}}\r\n\r\n        # the id parameter lets this function know what to look for in the dataframe.\r\n    assert id in ('v', 'b', 'e'), f\"YOU PROVIDED AN UNSUPPORTED ID TO PlottingWindow.Param_v_Step_callable!! {id} is not v, b, nor e!\"\r\n\r\n    # now that we know the column names associated with the data we want, we index the dataframe with the relevant info\r\n    #dfslice = df[df['id'] == 0] # right now, we only look at the 1st particle.\r\n    #x, y, z = dfslice[xn].to_numpy(), dfslice[yn].to_numpy(), dfslice[zn].to_numpy() #x, y, z coord points at each step\r\n    with h5py.File(path, 'r+') as f:\r\n        ds = f[h5_dct[id]['src']]\r\n        x, y, z = ds[h5_dct[id]['xn']], ds[h5_dct[id]['yn']], ds[h5_dct[id]['zn']]\r\n        coords = np.column_stack((x,y,z))\r\n        #print(coords)\r\n\r\n            # get the graphable components\r\n            # 1. the magnitude of the component at each step.\r\n        step_mag = magnitude_at_each_step(coords, f, h5_dct[id]['src'], h5_dct[id]['mag_key'])[:-1]\r\n        #print(step_mag)\r\n\r\n            # for now, b has only this line.\r\n        if id == 'b':\r\n            plot.plot(step_mag)\r\n            return True\r\n        else:\r\n            b_ds = f[h5_dct['b']['src']]\r\n                # everyone else gets parallel and perpendicular components also graphed, which are calculated relative to b.\r\n            #bx,by,bz = dfslice[\"bx\"].to_numpy(), dfslice[\"by\"].to_numpy(), dfslice[\"bz\"].to_numpy() # b components at each step to calculate v||, e||\r\n            bx, by, bz = b_ds[h5_dct['b']['xn']], b_ds[h5_dct['b']['yn']], b_ds[h5_dct['b']['zn']]\r\n            bs = np.column_stack((bx, by, bz)) # b coordinates all in one array.\r\n\r\n                # get the parallel and perpendicular components relative to b\r\n            step_parallel = get_parallel(bs, coords, f, h5_dct[id]['src'], h5_dct[id]['par_key'])[:-1]\r\n            step_perpendicular = get_perpendicular(bs, coords, f, h5_dct[id]['src'], h5_dct[id]['perp_key'])[:-1]\r\n\r\n                # graph these guys.\r\n            plot.plot(step_mag, label='mag', color='green')\r\n            plot.plot(step_parallel, label='p', color='blue')\r\n            plot.plot(step_perpendicular, label='perp', color='red')\r\n\r\n                # add a legend\r\n            plot.legend(bbox_to_anchor=(0, 1.15), loc='lower left', fontsize=4, ncol=3 )\r\n\r\n\r\ndef Trajectory_callable(fig, plot, path, c:mp.Collection, **kwargs):\r\n    \"\"\"\r\n    for graphing the 3d trajectory of a single particle.\r\n    \"\"\"\r\n    palettes = [\"copper\", \"gist_heat\"] # supported palettes for multiple particles.\r\n\r\n    with h5py.File(path, 'r') as f:\r\n        # get the number of particles. Because 'id' is working with a 0 index, add 1.\r\n        #nump = df[\"id\"].max() + 1\r\n        nump=1\r\n        # Graph trajectory for each particle\r\n        df = f['src/position']\r\n        for part in range(nump):\r\n            # extract data from dataframe\r\n            #dfslice = df[df[\"id\"] == part] # only using info from the corresponding particle id.\r\n            #x, y, z = dfslice[\"px\"].to_numpy(), dfslice[\"py\"].to_numpy(), dfslice[\"pz\"].to_numpy() #x, y, z coord points at each step\r\n            x, y, z = df[\"px\"], df[\"py\"], df[\"pz\"]  # x, y, z coord points at each step\r\n            # make the matching index's color palette a colormap distributed across the steps.\r\n            colors = mpl.colormaps[palettes[part]]\r\n\r\n            # actually plot everything.\r\n            plot.scatter(x,y,z, cmap=colors, c=np.linspace(0,1,len(x)), s=2.5)\r\n\r\n    # Additionally, we want to also show the coil configuration.\r\n    mp.show(c, canvas=plot)\r\n    plot.get_legend().remove()\r\n\r\n\r\n\r\n# option, style mapping, so the program knows what style goes with each option:\r\ngraph_option_style_map = {'Vel vs. Step' : {'id' : 'v', 'style': vel_step_style},\r\n                          'B-mag vs. Step' : {'id' : 'b', 'style' : b_step_style},\r\n                          'E-mag vs. Step': {'id' : 'e', 'style' : e_step_style}}\r\n\r\n'''\r\nthe following r the actual classes that implement the previously established settings and functions.\r\n'''\r\n# Custom toolbar\r\nclass CustomToolbar(NavigationToolbar2Tk):\r\n    \"\"\"\r\n    the same toolbar, except there is a new button that opens the canvas in its own window.\r\n    \"\"\"\r\n        \r\n    def open_window(self):\r\n        \"\"\"\r\n        function to open the figure in own window.\r\n        Also, the window CANNOT be in its own thread because matplotlib's show needs the main thread. \r\n\r\n        So this will open a tk.Toplevel window containing the figure instead.\r\n        \"\"\"\r\n        # create a toplevel object.\r\n        window = tk.Toplevel(self.root)\r\n\r\n        # FIGURE ACCESSING/FORMATTING\r\n        # we may need to pickle, depickle the figure to ensure we're working with an independent copy.\r\n        buf = io.BytesIO()\r\n        pickle.dump(self.canvas.figure, buf)\r\n        buf.seek(0)\r\n        fig = pickle.load(buf)\r\n\r\n        # resize the figure copy to the global settings.\r\n        fig.set_size_inches(toplevel_width, toplevel_height)\r\n        \r\n        # and then we also get a reference to the subplot so we can adjust the font sizes and stuff.\r\n        ax = fig.get_axes()[0]\r\n        ax.set_title(ax.get_title(), size=20)\r\n        ax.set_xlabel(ax.get_xlabel(), size=12, labelpad=4)\r\n        ax.set_ylabel(ax.get_ylabel(), size=12, labelpad=4)\r\n        if ax.name == '3d':\r\n            ax.set_zlabel(ax.get_zlabel(), size=12, labelpad=4)\r\n        ax.tick_params(axis='both', which='major', labelsize = 10, pad=4)\r\n        fig.tight_layout()\r\n\r\n        # FIGURE DRAWING\r\n        # add the figure and toolbar to the new window.\r\n        canvas = FigureCanvasTkAgg(master=window, figure=fig)\r\n        toolbar = NavigationToolbar2Tk(canvas, window)\r\n        canvas.get_tk_widget().pack(side='top')\r\n        canvas.draw()        \r\n        \r\n    def __init__(self,parent_, root_):\r\n        self.root = root_ # root refers to the parent window of the TK application.\r\n        self.toolitems += ((None, None, None, None), \r\n                           (\"Enlarge\", \"Opens graph in new window\", 'home', \"open_window\"))\r\n        NavigationToolbar2Tk.__init__(self,parent_)\r\n\r\n\r\n\r\n# CLASSES\r\nfrom PIL import ImageTk, Image\r\nimport definitions\r\n\"\"\"\r\nUpdate as of 5/15: the trajectory plot shown in the GUI will be a static image. Interactive options will be available via button press.\r\n\r\nThe figure in this class only updates when a new dataset .json is selected. It saves the figure as an image to its corresponding tempfile,\r\nand its canvas draws that image.\r\n\"\"\"\r\nclass StaticFigure(tk.Frame):\r\n    def __init__(self, master, png_path, graph_settings: dict = trajectory_style, **kwargs):\r\n            # tk Object(s) init\r\n        super().__init__(master, **kwargs)\r\n        self.graph_settings = graph_settings\r\n        self.png_full_path = f\"{png_path}.png\"\r\n        TEMPMANAGER_MANAGER.imgs.append(self.png_full_path)\r\n        #self.png_full_path = os.path.join(definitions.DIR_ROOT, f\"system\\\\imgs\\\\cat.png\")\r\n        self.img_frame = tk.Frame(self) # main container for the image\r\n        self.img_label = tk.Label(self.img_frame)\r\n\r\n            # mpl figure init\r\n        self.initFig()\r\n\r\n            # packing\r\n        self.img_frame.pack()\r\n        self.img_label.pack(side = \"bottom\", fill = \"both\", expand = \"yes\")\r\n    \r\n    \"\"\"\r\n    Called in init. \r\n    \"\"\"\r\n    def initFig(self):\r\n        self.fig = plt.figure()\r\n        projection = self.graph_settings['projection']\r\n        self.plot = self.fig.add_subplot(1,1,1, projection=projection)\r\n        # apply labels outlined in graph settings.\r\n        self.renameLabels()\r\n        # initialize with tight layout so axes labels don't get cut off.\r\n        self.fig.tight_layout()\r\n    \r\n    \"\"\"\r\n    Called in self.initFig, which is run in init.\r\n    \"\"\"\r\n    def renameLabels(self):\r\n        if self.plot is not None:\r\n            # load settings\r\n            title = self.graph_settings['title']\r\n            xlab = self.graph_settings['xlab']\r\n            ylab = self.graph_settings['ylab']\r\n            # apply settings\r\n            self.plot.set_title(title)\r\n            self.plot.set_xlabel(xlab)\r\n            self.plot.set_ylabel(ylab)\r\n            # things to do if there is a 3d projection \r\n            if self.graph_settings['projection'] == '3d':\r\n                self.plot.set_zlabel(self.graph_settings['zlab'])\r\n    \r\n    \"\"\"\r\n    Display the image in the object's image frame\r\n    \"\"\"\r\n    def displayImage(self):\r\n        self.im = ImageTk.PhotoImage(Image.open(self.png_full_path))\r\n        #self.im = ImageTk.PhotoImage(Image.open(os.path.join(definitions.DIR_ROOT, f\"Scripts\\\\system\\\\imgs\\\\cat.png\")))\r\n        #self.img_label.config(image = ImageTk.PhotoImage(Image.open(self.png_full_path)))\r\n        self.img_label.config(image = self.im)\r\n\r\n    \"\"\"\r\n    Clears and renames the plot.\r\n    \"\"\"\r\n    def prepareGraph(self):\r\n        # clear the plot of its impurities\r\n        self.plot.cla()\r\n        # replot the labels according to the settings.\r\n        self.renameLabels()\r\n\r\n    \"\"\"\r\n    Called only when new plotfile is chosen\r\n    \"\"\"\r\n    def updateGraph(self, df:pd.DataFrame, func:callable, **kwargs):\r\n        \"\"\"\r\n        When called, the selected graphing logic will be called once more.\r\n\r\n        It is expected that the dataframe is externally provided upon the function call.\r\n        \"\"\"\r\n        self.prepareGraph()\r\n        func(self.fig, self.plot, df, **kwargs) # the graphing logic is being applied here.\r\n        self.fig.savefig(self.png_full_path) # save to file. Will overwrite if file exists alr.\r\n\r\n        self.displayImage() # after saving, display the image to self.img_label (tk.Label)\r\n        return True\r\n\r\n\r\nclass CanvasFigure(tk.Frame):\r\n    \"\"\"\r\n    A class that contains a matplotlib figure inside of itself, navigable with tkinter.\r\n\r\n    Also has a button that opens the graph in a dedicated window. Because oftentimes things are small.\r\n    I think this is a good compromise between dedicated windows vs. in-program frames.\r\n        > you control the thing graphed and see its general shape in program\r\n        > you can then see the detailed view if you choose tol\r\n    \"\"\"\r\n\r\n    def __init__(self, master, root, **kwargs):\r\n        # default settings for the figure displayed by the canvas.\r\n        # used unless overwritten by kwargs.\r\n        self.graph_settings = graph_default.copy()\r\n        self.master = master\r\n        \r\n        # Overwrite any non-default settings.\r\n        # Remove graph_settings relevant keywords in case we want to pass any kwargs to tk.Frame\r\n        for key in self.graph_settings.keys():\r\n            if key in kwargs.keys():\r\n                self.graph_settings[key] = kwargs.pop(key)\r\n        \r\n        # Run init of tk.Frame\r\n        super().__init__(master, **kwargs)\r\n        self.config(highlightbackground='red', highlightthickness='1') # visualize frame bounds\r\n        \r\n        # REST OF INIT: CLASS SPECIFIC STUFF\r\n        # Instantiate figure\r\n        self.initFig()\r\n        # After instantiating the figure, it can be placed in a tk.Canvas\r\n        #self.button = tk.Button(master=self, text=\"Enlarge\")\r\n        #self.button.pack(side=tk.TOP)\r\n        self.canvas = tk.Canvas(master=self)\r\n        self.canvas.pack(side=tk.TOP, expand=1)\r\n        self.graph = FigureCanvasTkAgg(self.fig, self.canvas)\r\n        self.graph.get_tk_widget().pack(side=tk.TOP, expand=1, fill=tk.BOTH)\r\n        # add the navigation toolbar\r\n        self.toolbar = CustomToolbar(self.graph, root)\r\n\r\n    \r\n    def initFig(self):\r\n        \"\"\"\r\n        Instantiates a figure and subplot according to current settings.\r\n        \"\"\"\r\n        self.fig = plt.figure()\r\n        projection = self.graph_settings['projection']\r\n        #print(projection)\r\n        self.plot = self.fig.add_subplot(1,1,1, projection=projection)\r\n        # apply labels outlined in graph settings.\r\n        self.renameLabels()\r\n        # initialize with tight layout so axes labels don't get cut off.\r\n        self.fig.tight_layout()\r\n\r\n    def renameLabels(self):\r\n        \"\"\"\r\n        Selects titles and labels from graph_settings and applies it to the figure.\r\n        \"\"\"\r\n        if self.plot is not None:\r\n            # load settings\r\n            title = self.graph_settings['title']\r\n            xlab = self.graph_settings['xlab']\r\n            ylab = self.graph_settings['ylab']\r\n            # apply settings\r\n            self.plot.set_title(title)\r\n            self.plot.set_xlabel(xlab)\r\n            self.plot.set_ylabel(ylab)\r\n            # things to do if there is a 3d projection \r\n            if self.graph_settings['projection'] == '3d':\r\n                self.plot.set_zlabel(self.graph_settings['zlab'])\r\n\r\n    def prepareGraph(self):\r\n        \"\"\"\r\n        To graph on this plot again, you must clear the graph and reapply labels.\r\n        \"\"\"\r\n        # clear the plot of its impurities\r\n        self.plot.cla()\r\n        # replot the labels according to the settings.\r\n        self.renameLabels()\r\n\r\n    def updateGraph(self, func:callable, path, **kwargs):\r\n        \"\"\"\r\n        When called, the selected graphing logic will be called once more.\r\n\r\n        It is expected that the dataframe is externally provided upon the function call.\r\n        \"\"\"\r\n        self.prepareGraph()\r\n        func(self.fig, self.plot, path, **kwargs) # the graphing logic is being applied here.\r\n        return True\r\n\r\nclass DropdownFigure(tk.Frame):\r\n    \"\"\"\r\n    A FRAME THAT WILL CONTAIN A COMBOBOX.\r\n    THIS COMBOBOX WILL HAVE VARIOUS GRAPHING OPTIONS TO CHOOSE FROM,\r\n    WHICH WILL AUTOMATICALLY UPDATE THE INCLUDED GRAPH.\r\n    \"\"\"\r\n    def __init__(self, master, root, **kwargs):\r\n        self.master = master\r\n        super().__init__(master, **kwargs)\r\n        # store references to children\r\n        self.canvFig = CanvasFigure(master=self, root=root, **kwargs)\r\n        # elevating some CanvasFigure properties so I can access it as a DropdownFigure easily.\r\n        self.canvas = self.canvFig.canvas\r\n        self.graph = self.canvFig.graph\r\n        self.fig = self.canvFig.fig\r\n        self.plot = self.canvFig.plot\r\n        self.settings = self.canvFig.graph_settings\r\n        \r\n        # properties for handling comboboxes. \r\n        self.chosenVal = tk.StringVar() # keep the chosen combobox option here so I can moderate changes.\r\n        self.dropdown = ttk.Combobox(self, textvariable=self.chosenVal, state='readonly')\r\n        # set options to the tuple defined at the top of the document\r\n        self.dropdown['values'] = graph_options\r\n\r\n        # Its widgets (dropdown mainly) will take up the top line, then the rest of the space\r\n        # is for the canvas figure object\r\n        self.dropdown.pack(expand=1, fill=\"x\", side=tk.TOP)\r\n        self.canvFig.pack(expand=1, fill=tk.BOTH, side=tk.TOP)\r\n\r\n        # bind the combobox to appropriate events, like updating the internal style dictionary\r\n        #self.dropdown.bind(\"<<ComboboxSelected>>\", self.update_graph_settings)\r\n    \r\n    def external_bind(self, external_class):\r\n        \"\"\"\r\n        when called, the external class will be bound to this object's combobox selected event\r\n        with the function update_dropdown.\r\n\r\n        I did this to make sure the combobox selected event could still retain a reference to the\r\n        class instance that triggered it. (and update_graph_settings requires external class info for the dataframe).\r\n        \"\"\"\r\n        self.dropdown.bind(\"<<ComboboxSelected>>\", lambda event, i=self: external_class.update_dropdown(event, i))\r\n    \r\n    def update_graph_settings(self, event):\r\n        \"\"\"\r\n        Whenever a new graph setting is chosen (a new value for the dropdown), the internal style dictionary gets \r\n        updated accordingly.\r\n\r\n        Reminder: the style to option map is set at the top of this document.\r\n        \"\"\"\r\n        # load the new dictionary\r\n        new_dict = graph_option_style_map[self.chosenVal.get()]['style']\r\n        # update the current dictionary with this one.\r\n        self.settings = self.canvFig.graph_settings.update(new_dict)\r\n        #print(self.settings)\r\n    \r\n    def updateGraph(self, path, **kwargs):\r\n        \"\"\"\r\n        calls the updateGraph function (with identical parameters) to the CanvasFigure object.\r\n        \"\"\"\r\n        try:\r\n            # get the id: a value associated with the currently selected dropdown menu option.\r\n            id = graph_option_style_map[self.chosenVal.get()]['id']\r\n\r\n            # only do graphing stuff if id is not none; if something is acutally chosen lol.\r\n            if id is not None:\r\n                #print(\"you should be updating a dropdown graph.\")\r\n                self.canvFig.updateGraph(Param_v_Step_callable, path, id=id)\r\n        except:\r\n            return False\r\n\r\nclass PlottingWindowObj(tk.Frame):\r\n    \"\"\"\r\n    A high level class that contains the layout of the plotting window.\r\n\r\n    Event handling done internally to ensure window resizing doesn't mess up graphs.\r\n    \r\n    Calls to update graph done as follows:\r\n        - the trajectory graph is updated from an external function call (in BorisGui), when a dataset file is selected.\r\n        - the two programmable graphs are updated when a dropdown value is chosen, AND when there is a valid dataset file selected.\r\n    \r\n    This is accomplished by having the external event update the internal property 'df', which is a dataframe that is read from the .json dataset file.\r\n    This internal property, after being updated, will have the program run its graphing function, in which the trajectory graph is updated according to the dataset.\r\n    The two programmable graphs will check their corresponding dropdown box for the graphing logic to apply.\r\n    \"\"\"\r\n    \r\n    def __init__(self, master, root, label:tk.StringVar):\r\n        # these settings are in pixels.\r\n        self.padx = 5\r\n        self.pady = 0\r\n\r\n        self.root = root # a reference to the program's main window is necessary to get the window size.\r\n                         # it's also needed to make a new toplevel window for my custom toolbar button press event.\r\n        self.master = master\r\n        self.df = None # the dataset read from the .json output file.\r\n        self.c = None # the magpylib.collection object that was used to run the simulation.\r\n        self.path = label\r\n        self._path = self.path.get()\r\n        self._h_path = None\r\n        super().__init__(master)\r\n        self.config(highlightbackground='black', highlightthickness='2') # visualize frame bounds\r\n\r\n        # we want a 3-plot structure with the trajectory plot dominating a whole column to itself.\r\n        # Create figures.\r\n        self.trajectory = StaticFigure(master=self, \r\n                                       png_path=TEMPMANAGER_MANAGER.files[names.m1f2],\r\n                                       graph_settings=trajectory_style)\r\n        self.trajectory.plot.set_box_aspect([1,1,1]) # make the 3d bounding box always square.\r\n        self.graph1 = DropdownFigure(self, root)\r\n        self.graph2 = DropdownFigure(self, root)\r\n\r\n        # also for dropdown figures, we need to subscribe to their combobox changed events.\r\n        # REMINDER: THIS IS SO THAT WE CAN PASS THE DATAFRAME PROPERTY FROM THIS CLASS TO THE DROPDOWNS WHILE TRIGGERING UPDATES FROM TK EVENTS.\r\n        # update_dropdown from this class runs because of this.\r\n        self.graph1.external_bind(self)\r\n        self.graph2.external_bind(self)\r\n\r\n        # Store figures and the canvases they live on.\r\n        self.figs = [self.trajectory.fig, self.graph1.fig, self.graph2.fig] # the mpl fig object\r\n        self.graphs = [self.graph1.graph, self.graph2.graph] # the FigureCanvasTkAgg objects\r\n        self.plots = [self.trajectory.plot, self.graph1.plot, self.graph2.plot] # the subplots in the mpl figs\r\n        self.canvases = [self.graph1.canvas, self.graph2.canvas] # the canvases that hold the FigureCanvasTkAggs\r\n\r\n        # additional figure containers, for just holding the dropdown graphs.\r\n        self.dropdown_figures = [self.graph1.fig, self.graph2.fig]\r\n        self.dropdown_graphs = [self.graph1.graph, self.graph2.graph]\r\n\r\n        # packing step\r\n        self.trajectory.pack(expand=1, side=tk.LEFT, anchor=\"w\", ipadx=3, ipady=3, padx=5)\r\n        self.graph1.pack(side=tk.TOP, anchor='ne', expand=1, ipadx=3, ipady=3, padx=1, pady=2)\r\n        self.graph2.pack(side=tk.TOP, anchor='se', expand=1, ipadx=3, ipady=3, padx=1, pady=2)\r\n\r\n        # event bindings:\r\n        self.set_active() # resizing based on window size\r\n        self.path.trace_add('write', self.read_dataframe)\r\n\r\n    def update_all_graphs(self):\r\n        \"\"\"\r\n        calls its graph components' graphing functions with appropriate parameters.\r\n        Intended to be a global event thing that happens when we want to update all the graphs at once.\r\n        (like when a dataset file is selected).\r\n        \"\"\"\r\n        #print(self.df)\r\n        # trajectory callable needs: the fig, plot, dataframe, collection.\r\n        traj_args = {'c' : self.c}\r\n        self.trajectory.updateGraph(self._h_path, Trajectory_callable, **traj_args)\r\n        # everything else's callable needs: the fig, plot, dataframe, id.\r\n        # these are decided in the DropdownFigure object themselves.\r\n        self.graph1.updateGraph(self._h_path)\r\n        self.graph2.updateGraph(self._h_path)\r\n        self.resize_callback(None)\r\n\r\n    def update_dropdown(self, event, dropdown):\r\n        \"\"\"\r\n        because the dropdown figures still need access to this object's df property, the call for it must happen from here as well.\r\n        we will access the specific object that caused this to run from the event.\r\n\r\n        this is running every combobox update.\r\n        \r\n        PARAMS:\r\n        dropdown = the instance of DropdownFigure responsible for this trigger. \r\n        \"\"\"\r\n        dropdown.update_graph_settings(event)\r\n        dropdown.updateGraph(self._h_path)\r\n        self.resize_callback(None)\r\n    \r\n    \"\"\"\r\n    path is expected to be the parent dir to a known .h5 file with the same structure as defined in files.hdf5.output_file_structure\r\n    \r\n    \"\"\"\r\n    def read_dataframe(self, *args):\r\n        path = self.path.get()\r\n        self._path = str(Path(path).parents[0])\r\n        self._h_path = os.path.join(self._path, 'data.hdf5')\r\n        self.c = self.File_to_Collection(path)  # reconstructs the magpylib collection object that was used.\r\n        self.update_all_graphs()\r\n\r\n\r\n    '''def read_dataframe(self, *args):\r\n        \"\"\"\r\n        path is expected to be the full dataset path.\r\n        The dataset is also expected to be a .json file in the 'table' orientation, as it's what the program spits out.\r\n\r\n        If both of these conditions are met, the function updates its internal 'df' property with it.\r\n\r\n        This function also updates the c property with the reconstructed magpylib collections object that was used in the simulation,\r\n        which is used for graphing the trajectory.\r\n        \"\"\"\r\n        #print(self.path.get())\r\n        try:\r\n            # first thing is to read the selected dataset and populate relevant properties.\r\n            if os.path.exists(self.path.get()):\r\n                path = self.path.get()\r\n                self.df = pd.read_json(path, orient='table') # reads the .json file and constructs it as a pandas dataframe.\r\n                #print(f\"dataframe reading passed\")\r\n                self.c = self.File_to_Collection(path) # reconstructs the magpylib collection object that was used.\r\n                #print(f\"collection creaiton passed\")\r\n                #print(self.df)\r\n            else:\r\n                print(f\"Path {path} does not exist.\")\r\n        except ValueError:\r\n            print(f\"Plottingwindow.PlottingWindowObj.read_dataframe: provided path does not meet the requirements of being a .json file in the table orientation, or the provided collection is\")\r\n        \r\n        self.update_all_graphs()'''\r\n    \r\n    def File_to_Collection(self, path):\r\n        \"\"\"\r\n         1. locate the coils file, assuming that path is the dir. to the json.\r\n         2. return the coils as a magpy collection object.\r\n        \"\"\"\r\n        c = mp.Collection()\r\n        proot = str(Path(path).parents[0]) # boris_<nsteps>_<simtime>_<nparts>\r\n        #print(f\"{path}, {root}\")\r\n        coilpath = os.path.join(proot, \"coils.txt\") # boris_<nsteps>_<simtime>_<nparts>/coils.txt\r\n        \r\n        # in case the output folder does not have a coils.txt file.\r\n        if(not os.path.exists(coilpath)):\r\n            messagebox.showwarning(Title_Notif.warning, Popup_Notifs.err_plot_missing_coil)\r\n            return c # return an empty collection \r\n\r\n        df=None\r\n        # store coils and rotations separately, so that we can apply the rotations afterwards\r\n        df = CSV_to_Df(coilpath, converters={\"Amp\":tryEval, \"RotationAngle\":tryEval, \"RotationAxis\":tryEval}, isNum=False, header=0)\r\n        #print(df)\r\n        for i, row in df.iterrows():\r\n            row = row.tolist()\r\n            position = [float(row[0]), float(row[1]), float(row[2])]\r\n            #print(tryEval(row[6]))\r\n            coil = Circle(position, current=float(row[3]), diameter=float(row[4]))\r\n            #print(coil)\r\n            match row[5]:\r\n                case float():\r\n                    coil.rotate_from_angax(row[5], row[6])\r\n                case int():\r\n                    coil.rotate_from_angax(row[5], row[6])\r\n                case list():\r\n                    for i in range(len(row[5])):\r\n                        coil.rotate_from_angax(float(row[5][i]), row[6][i])\r\n            \r\n            c.add(coil)\r\n       #print(c)\r\n        return c\r\n\r\n    def set_active(self):\r\n        \"\"\"\r\n        binds to the configure event on window size change.\r\n        \"\"\"\r\n        # Bind window size change event to resize callback\r\n        self.root.bind(\"<Configure>\", self.resize_callback)\r\n\r\n    def set_inactive(self):\r\n        \"\"\"\r\n        Makes the object no longer care about window size changes.\r\n        \"\"\"\r\n        self.root.unbind(\"<Configure>\", self.resize_callback)\r\n\r\n    def _redraw_graphs(self, figs, graphs, context, z=False):\r\n        \"\"\"\r\n        internal function used to abstract the function call to redraw the object's internal figures.\r\n        \"\"\"\r\n        size = context['font.size']\r\n        padding = size * 0.01\r\n        for fig in figs:\r\n            for ax in fig.axes:\r\n                # update title\r\n                ax.title.set_fontsize(size)\r\n                # x - axis\r\n                ax.xaxis.label.set_fontsize(size*0.75) # size of text\r\n                ax.xaxis.labelpad = padding\r\n                # y - axis\r\n                ax.yaxis.label.set_fontsize(size*0.75)\r\n                ax.yaxis.labelpad = padding\r\n                # ticks\r\n                ax.tick_params(axis='both', which='major', labelsize = size*0.75, pad=padding)\r\n                if(z):\r\n                    padding = padding * 0.001\r\n                    # in 3d graphs, also mess with z axis stuff.\r\n                    ax.set_xlabel(ax.get_xlabel(), labelpad=padding)\r\n                    ax.set_ylabel(ax.get_ylabel(), labelpad=padding)\r\n                    ax.set_zlabel(ax.get_zlabel(), labelpad=padding)\r\n                    ax.zaxis.label.set_fontsize(size*0.75)\r\n                    ax.zaxis.labelpad = padding\r\n                    ax.tick_params(axis='z', which='major', labelsize = size*0.75, pad=padding)\r\n            fig.tight_layout()\r\n        for graph in graphs:\r\n            graph.draw()\r\n    \r\n    def redraw_graphs(self, mode='all', traj_rc = None, dropdown_rc = None):\r\n        '''\r\n        globally redraw all graphs this components is responsible for.\r\n        '''\r\n        modes = ['all', 'traj', 'dropdown']\r\n        assert mode in modes, f\"Value error: the mode argument {mode} not in {modes}\"\r\n\r\n        match mode:\r\n            case 'all':\r\n               assert (traj_rc is not None and dropdown_rc is not None)\r\n               # in 'all' mode, the function calls itself to update the trajectory and dropdown graphs.\r\n               #self.redraw_graphs('traj', traj_rc=traj_rc)\r\n               self.redraw_graphs('dropdown', dropdown_rc=dropdown_rc)\r\n            case 'traj':\r\n                assert traj_rc is not None\r\n                self._redraw_graphs([self.trajectory.fig], traj_rc, z=True)\r\n            case 'dropdown':\r\n                assert dropdown_rc is not None\r\n                self._redraw_graphs(self.dropdown_figures, self.dropdown_graphs, dropdown_rc)\r\n\r\n    def resize_callback(self, event):\r\n        \"\"\"\r\n        We want to enforce the size of each graphing element.\r\n        Not only within the window(so that they don't overflow), but also within the frame (the trajectory graph should be larger).\r\n        \"\"\"\r\n        # get the current window width and height\r\n        width = self.root.winfo_width()\r\n        height = self.root.winfo_height()\r\n        \r\n        # **I'm going to measure the desired size by percentages of the window size.\r\n        # Trajectory graph will be clamped to be a square aspect ratio, so both width and height should have the same value.\r\n        w_h_avg = (width + height) / 2\r\n        traj_width = ((w_h_avg * 0.45))\r\n        traj_height = ((w_h_avg * 0.45))\r\n\r\n        g1_width = ((width * 0.4))\r\n        g1_height = ((height * 0.25))\r\n\r\n        # set canvas sizes.\r\n        # To enforce strict size limits on the mpl figures, we set the FigureCanvasTkAgg object's internal canvas widget's size.\r\n        #self.graphs[0].get_tk_widget().config(width=traj_width, height=traj_height)\r\n        self.graphs[0].get_tk_widget().config(width=g1_width, height=g1_height)\r\n        self.graphs[1].get_tk_widget().config(width=g1_width, height=g1_height)\r\n\r\n        # GET TEMP. RC STYLE CONTEXTS FOR LABEL PADDING AND SCALING.\r\n        # font sizing will get the ratio between the length and height of the frame (in pixels) and multiply it by their respective proportions.\r\n        w_h_ratio = width/height\r\n\r\n        traj_font_size = trajectory_font_textsize_proportion\r\n        dropdown_font_size = w_h_ratio * dropdown_font_textsize_proportion\r\n\r\n        #print(f\"{traj_font_size}\")\r\n        #print(f\"{dropdown_font_size}\")\r\n\r\n        traj_rc = {'font.size' : traj_font_size, 'axes.labelpad' : traj_font_size, 'axes.titlesize' : traj_font_size}\r\n        dropdown_rc = {'font.size' : dropdown_font_size, 'axes.labelpad' : dropdown_font_size, 'axes.titlesize' : dropdown_font_size}\r\n\r\n        # redraw the graphs\r\n        self.redraw_graphs('all', traj_rc = traj_rc, dropdown_rc = dropdown_rc)\r\n\r\ndef on_main_notebook_tab_changed(event, plotObj:PlottingWindowObj):\r\n    \"\"\"\r\n    Graph resizing does not behave as expected when done on figures that are on inactive tabs.\r\n    This is because the figures have not been rendered yet.\r\n\r\n    Therefore, the figures need to be rendered specifically when they become active.\r\n    \"\"\"\r\n    # get the name of the active tab.\r\n    widget = event.widget\r\n    tab_name = widget.tab(widget.select(), \"text\")\r\n    # when the active tab is the plotting tab, then redraw the figures to ensure they render correctly.\r\n    if tab_name == \"Plot\":\r\n        # 1. make the object care about window size changes\r\n        #plotObj.set_active()\r\n        # 2. manually call the resize callback just this once.\r\n        plotObj.resize_callback(None)\r\n    else:\r\n        # if the name of the tab is not Plot, then make sure the object is unbound from the window change event.\r\n       #plotObj.set_inactive()\r\n       pass\r\n\r\n\r\n\"\"\"\r\ndeprecated because I want a more OOP approach to adding multiple figures.\r\n\"\"\"\r\nclass TrajGraph(tk.Canvas):\r\n    def __init__(self, master, stride_lower=1, stride_upper=100, **kwargs):\r\n        mpl.use(\"tkagg\")\r\n        self.master = master\r\n        self.title = \"Trajectory\"\r\n\r\n        #Var to read currently selected Stride\r\n        self.stride_var = tk.IntVar()\r\n\r\n        # Instantiate canvas\r\n        super().__init__(master, **kwargs)\r\n\r\n        self.frame = tk.Frame(self)\r\n\r\n        # Create slider for Stride\r\n        stride_slider = tk.Scale(self.frame, variable=self.stride_var, \r\n                                 from_=stride_lower, to=stride_upper,\r\n                                 orient=\"horizontal\")\r\n        stride_label = tk.Label(self.frame, text=\"Step Stride\")\r\n        \r\n        # Create graph\r\n        #self.ConstructGraph()\r\n\r\n        self.window = self.create_window(0,0, window=self.frame, anchor=\"nw\")\r\n\r\n        # Packing\r\n        stride_label.pack()\r\n        stride_slider.pack(side=\"top\", fill=\"x\", expand=True)\r\n        #self.frame.pack(side='top', fill='x', expand=True)\r\n        #self.canvas.get_tk_widget().pack(fill=\"both\", expand=True)\r\n        #self.toolbar.pack(side=tk.BOTTOM, fill=\"x\")\r\n        #self.pack(fill=\"both\", expand=True, side=\"top\")\r\n\r\n        # Bind self to re-register the scroll area upon window dimension change\r\n        self.bind('<Configure>', self._on_Configure)\r\n\r\n    def _on_Configure(self, event):\r\n        \"\"\"\r\n        Intended to run whenever the root window's dimensions change.\r\n            - resize the frame\r\n            - update the scroll area.\r\n        \"\"\"\r\n        # Get updated window width\r\n        w = event.width\r\n\r\n        # Adjust the canvas element(self) to the updated width, to match\r\n        self.itemconfig(self.window, width = w)\r\n    \r\n    def ConstructGraph(self):\r\n            \"\"\"\r\n            creates a matplotlib figure\r\n            \"\"\"\r\n            self.fig = plt.figure()\r\n            self.plot = self.fig.add_subplot(1,2,1, projection='3d')\r\n\r\n            self.plot_vcross = self.fig.add_subplot(2,2,2)\r\n            self.plot_02 = self.fig.add_subplot(2,2,3)\r\n\r\n            #self.canvas = FigureCanvasTkAgg(self.fig, master=self)\r\n            #self.toolbar = NavigationToolbar2Tk(self.canvas, pack_toolbar=False)\r\n            #self.toolbar.pack(side=\"bottom\")\r\n            self.fig.tight_layout()\r\n            #self.canvas.draw()\r\n    \r\n    def SetAxis(self):\r\n        self.plot_vcross.set_title('Velocity')\r\n        self.plot_vcross.set_xlabel('Step Number')\r\n        self.plot_vcross.set_ylabel('M/s')\r\n        self.plot_vcross.legend(['Vel Magnitude', 'Vx', 'Vy', 'Vz'], ncol=2, fancybox=True, shadow=True, loc=\"upper center\", bbox_to_anchor=(0.5, -0.25))\r\n\r\n        self.plot.set_xlabel(\"X (m)\")\r\n        self.plot.set_ylabel(\"Y (m)\")\r\n        self.plot.set_zlabel(\"Z (m)\")\r\n\r\n\r\n    def File_to_Collection(self, path):\r\n        \"\"\"\r\n         1. locate the coils file, assuming that path is the dir. to the json.\r\n         2. return the coils as a magpy collection object.\r\n        \"\"\"\r\n        proot = str(Path(path).parents[0]) # boris_<nsteps>_<simtime>_<nparts>\r\n        #print(f\"{path}, {root}\")\r\n        coilpath = os.path.join(proot, \"coils.txt\") # boris_<nsteps>_<simtime>_<nparts>/coils.txt\r\n        print(coilpath)\r\n        df=None\r\n        \r\n        # store coils and rotations separately, so that we can apply the rotations afterwards\r\n        c = mp.Collection()\r\n        df = CSV_to_Df(coilpath, converters={\"Amp\":tryEval, \"RotationAngle\":tryEval, \"RotationAxis\":tryEval}, isNum=False, header=0)\r\n        #print(df)\r\n        for i, row in df.iterrows():\r\n            row = row.tolist()\r\n            position = [float(row[0]), float(row[1]), float(row[2])]\r\n            coil = Circle(position, current=float(tryEval(row[3])), diameter=float(row[4]))\r\n\r\n            match row[5]:\r\n                case float():\r\n                    coil.rotate_from_angax(row[5], row[6])\r\n                case int():\r\n                    coil.rotate_from_angax(row[5], row[6])\r\n                case list():\r\n                    out = []\r\n                    for i in range(len(row[5])):\r\n                        coil.rotate_from_angax(row[5][i], row[6][i])\r\n            \r\n            c.add(coil)\r\n\r\n        return c\r\n\r\n\r\n    def UpdateGraph(self, label:tk.Label):\r\n        \"\"\"\r\n        called whenever the 'plot' button is pressed. Updates the graph in the frame with the trajectory.\r\n        \"\"\"\r\n        self.ConstructGraph()\r\n\r\n        self.plot.cla() # reset plot\r\n        self.plot_vcross.cla()\r\n\r\n        # Read data at the supplied path\r\n        path = label.cget(\"text\")\r\n        c = self.File_to_Collection(path) # magpy.collection object\r\n        df = JSON_to_Df(path) # dataframe\r\n\r\n        # Get GUI value for graph resolution\r\n        stride = int(self.stride_var.get())\r\n\r\n        # Color scaling based on time\r\n        palettes = [\"copper\", \"gist_heat\"]\r\n        nump = df[\"id\"].max() + 1\r\n\r\n        # Graph trajectory for each particle\r\n        for part in range(nump):\r\n            # extract data from dataframe\r\n            dfslice = df[df[\"id\"] == part]\r\n            x, y, z = dfslice[\"px\"].to_numpy(), dfslice[\"py\"].to_numpy(), dfslice[\"pz\"].to_numpy() #x, y, z coord points\r\n            coords = np.column_stack((x,y,z))\r\n            vx, vy, vz = dfslice[\"vx\"].to_numpy(), dfslice[\"vy\"].to_numpy(), dfslice[\"vz\"].to_numpy()\r\n            vels = np.column_stack((vx,vy,vz))\r\n            bx,by,bz = dfslice[\"bx\"].to_numpy(), dfslice[\"by\"].to_numpy(), dfslice[\"bz\"].to_numpy()\r\n            bs = np.column_stack((bx,by,bz))\r\n\r\n            vcrossmag, bmag, vcross_sq, vSum, v_mag, vels = CalculateLoss(vels, bs, 100)\r\n            vcrossmag_zeros = np.where(vcrossmag == 0)\r\n            #print(vcrossmag_zeros)\r\n\r\n            # Apply stride by using a bool mask to get every 'stride-th' point.\r\n            mask = np.ones(len(x), dtype=bool)\r\n            mask[:] = False\r\n            mask[np.arange(0, len(x), stride)] = True\r\n\r\n            # update the x, y, z arrays with bool mask\r\n            x = x[mask]\r\n            y = y[mask]\r\n            z = z[mask]\r\n            # Color the points based on step count\r\n            colors = mpl.colormaps[palettes[part]]\r\n            self.plot.scatter(x,y,z, cmap=colors, c=np.linspace(0,1,len(x)), s=2.5)\r\n            #self.plot_vcross.plot(vcrossmag)\r\n            #self.plot_vcross.plot(bmag)\r\n            #self.plot_vcross.plot(vcross_sq)\r\n            #self.plot_vcross.plot(vSum)\r\n            self.plot_vcross.plot(v_mag)\r\n            self.plot_vcross.plot(vels)\r\n\r\n        mp.show(c, canvas=self.plot)\r\n        self.SetAxis()\r\n        self.plot.get_legend().remove()\r\n        self.fig.tight_layout()\r\n        self.fig.show()\r\n        #self.canvas.draw()\r\n        #print(f'graphing finished.')\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Scripts/Gui_tkinter/widgets/PlottingWindow.py b/Scripts/Gui_tkinter/widgets/PlottingWindow.py
--- a/Scripts/Gui_tkinter/widgets/PlottingWindow.py	(revision 8f834f284014addf4c9f383d3f185fe92cd4d868)
+++ b/Scripts/Gui_tkinter/widgets/PlottingWindow.py	(date 1748896463973)
@@ -153,6 +153,7 @@
             plot.plot(step_mag, label='mag', color='green')
             plot.plot(step_parallel, label='p', color='blue')
             plot.plot(step_perpendicular, label='perp', color='red')
+            plot.grid()
 
                 # add a legend
             plot.legend(bbox_to_anchor=(0, 1.15), loc='lower left', fontsize=4, ncol=3 )
